学习原因：本人的人生rpg游戏中，需要一个玩家自定义事项的功能，具体而言就是类似于添加一个项目到to do list，参考了诸位大神的blog，决定使用vector实现该功能，于是就顺带开始学习顺序容器。

学习参考资料：C++ Primer , C++ Primer Plus


顺序容器

  array 类似于原生数组，静态的长度固定的，但是成员函数比原生数组丰富，拥有更安全易用的接口，如size（），==比较大小
  
  vector 非固定大小数组，可以快速访问（优势）
  
  list/forward_list 双/单向链表，优缺点就是链表的优缺点，不能快速访问，但是删减、插入元素快。
  
  容器拥有共同的接口（通用）

  
选择最好的容器

  数据结构方面的内容，一般而言，不知道选什么就用vector。

容器的操作
  需头文件，名字一般与容器名相同
  #include <vector>
  顺序容器可保存各种类型的数据，如: vector<vector<string>> lines
    lines是vector，其中每一个元素是string的vector
  容器操作--自己查表

迭代器
    类似于我们遍历数组时的i，与指针有点相似
    为什么要迭代器？list类型无法通过i来遍历
    简单的迭代器使用
    vector<int> s={1,2,3,4};
    for(auto it=v.begin();it!=vector.end();it++){ \\与指针遍历数组高度一致
        std:: cout<<*it<<" ";
    }
    注意有一个例外不符合公共接口，就是forward_list不支持--操作（因为是单向链表）
    迭代器范围：由两个迭代器组成的中间范围，一般是begin和end，【begin，end）

    迭代器课后习题1
    1，索引int类型的vector中元素，用什么类型

    首先明确，vector可以下标直接访问，int即可，但vector.size()返回的类型是size_t所以用size_t更好


    2，读取string类型的list用什么，如果写入呢

    核心区别是写入和读取，读取直接使用常量迭代器 list<string>::const_iterator,通过*it解引用来读取，写入则是通过list<string>::iterator

    迭代器的auto使用
    auto it1=a.begin(); //list<string>::iterator;
    auto it1=a.cbegin(); //list<string>::const_iterator;
    注意如果定义是 const list<string> a;则即使auto it1=a.begin();返回的也是iterator类型；

    容器的初始化
    初始化为另一个容器的拷贝   C（vector<int>） c1(c2)         将c1初始化为c2
    初始化为一个容器的部分，使用迭代器    vector<int>  c1(a,b);  a,b是两个迭代器
    列表初始化    vector<int> a={1,2,3};
    利用大小的初始化（array不适用） vector<int> a (10,1); 十个为1的元素；


    特殊的array
    与内置数组不同的点，可以拷贝，只要类型大小相同，for example:
    int a[3]={1,2,3};
    int b[3]=a;   错
    vector<int> a={1,2,3};
    vector<int> b=a; 对

    赋值操作
    C1=C2

    加入删减元素
    push_back
    push_front
    insert 
    需要使用时自己去查
    
